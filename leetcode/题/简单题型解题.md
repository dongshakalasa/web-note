# 2 - 17

## 1、两数之和

```js
const twoSum = (nums, target) => {
    const preNum = {}
    for(let i=0;nums.length;i++) {
        const item = nums[i]  // 遍历元素
        const n = target - item // 获取目标值
        const preNumIndex = preNum[n] // 在preNum中获取目标值的索引
        if (preNumIndex != undefined) {
            return [preNumIndex,i] // 存在，返回结果
        } else {
            preNum[item] = i // 不存在，存入当前元素和对应下标
        }
    }
}
```

```js
var twoSum = function(nums, target) {
    let map = new Map();
    for(let i = 0, len = nums.length; i < len; i++){
        if(map.has(target - nums[i])){
            return [map.get(target - nums[i]), i];
        }else{
            map.set(nums[i], i);
        }
    }
    return [];
};
```



## 2、回文数

```js
var isPalindrome = function(x) {
    let list = x.toString()
    let len = list.length
    let mid = list.length / 2
    for(let i=0;i<mid;i++) {
        if(list[i] == list[len - i - 1]) {
            continue
        }else {
            return false
        }
    }
    return true
};
```

# 2 - 20

## 1、有效的括号

```js
function fun(s) {
    if(s.length % 2 === 1) {
        return false
    }
    const map = new Map([
        [')','('],
        [']','['],
        ['}','{']
    ])
    const tack = []
    for(let ch of s) {
        if(map.has(ch)) {
            if(!tack.length || tack[tack.length - 1] !== map.get(ch)) {
                return false
			}
            tack.pop()
        }else {
            tack.push(ch)
        }
    }
    return !tack.length
}
```

## 2、合并两个有序链表

```js
/* 
* function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */

// 递归
function fun(l1,l2) {
    if(l1 === null) {
        return l2
    }else if(l2 === null) {
        return l1
    }else if(l1.val < l2.val) {
        l1.next = fun(l1.next,l2)
        return l1
    }else {
        l2.next = fun(l1,l2.next)
        return l2
    }
}

// 迭代
function fun1(l1,l2) {
    const prehead = new ListNode(-1)
    let pre = prehead
    while(l1 !== null && l2 !== null) {
        if(l1.val < l2.val) {
            pre.next = l1
            l1 = l1.next
        }else {
            pre.next = l2
            l2 = l2.next
        }
        pre = pre.next
    }
    pre.next = l1 !== null ? l1:l2
    return prehead.next
}
```



## 3、爬楼梯

```js
function fn(n) {
    let p = 0,q=0,r=1
    for(let i=1;i<=n;i++) {
        p = q;
        q = r;
        r = p+q
    }
    return r
}
```

