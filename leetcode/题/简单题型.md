# 2 - 17

## 1、两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

## 2、回文数

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

# 2 - 20

## 1、有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

## 2、合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```js
// 迭代
function fn(l1,l2) {
    if(l1 == null) {
        return l2
    }else if(l2 == null) {
        return l1
    }else if(l1.val < l2.val) {
        l1.next = fn(l1.next,l2)
        return l1
    }else {
        l2.next = fn(l1,l2.next)
        return l2
    }
}

// 迭代
function fn(l1,l2) {
    const prehead = new ListNode(-1)
    let pre = prehead
    while(l1!=null && l2!=null) {
        if(l1.val < l2.val) {
            pre.next = l1
            l1 = l1.next
        }else {
            pre.next = l2
            l2 = l2.next
        }
        pre = pre.next
    }
    pre.next = l1 !== null ? l1:l2
    return prehead.next
}
```



## 3、爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

# 2-21

## 1、二叉树的中序遍历

给定一个二叉树的根节点 root ，返回 它的 中序遍历。

## 2、对称二叉树

给你一个二叉树的根节点 root ， 检查它是否轴对称。

# 2 - 22

## 1、二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

## 2、买卖股票的最佳时机

给定一个数组 prices ，它的第 `i` 个元素 prices[i] 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
