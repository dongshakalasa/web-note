# vue生命周期

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpdate
- updated
- beforeDestroy
- destroyed

# 路由有哪几种

- hash模式
- history模式

# 虚拟dom

## 1、什么是虚拟dm

- 虚拟dom本质上就是一个普通的JS对象，用于描述视图的界面结构
- 在vue中，每个组件都有一个`render`函数，每个`render`函数都会返回一个虚拟dom树，这也就意味着每个组件都对应一棵虚拟DOM树

## 2、为什么需要虚拟dom

- 直接使用真实`DOM`，由于真实`DOM`的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率
- 在vue中如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用[render](https://so.csdn.net/so/search?q=render&spm=1001.2101.3001.7020)函数，创建出一个新的虚拟dom树，用新树和旧树对比，通过对比，vue会找到最小更新量，然后更新必要的真实dom节点

# 单向数据流

- 在父传子的前提下，父组件的数据发生会通知子组件自动更新
- 子组件内部，不能直接修改父组件传递过来的props => props是只读的
- 引用数据类型除外

# v-for的key

通过key值进行比较，如果相同就复用，不相同就更新

使用index的话，如果数组从首部添加一个数据，那么比较就会错开，全部更新，没有复用

# 插槽

- 默认插槽
  1. 在子组件留下<solt\></solt\>标签
  2. 在父组件中的子组件标签中写内容，书写的内容会替换在插槽位置
- 具名插槽
  - 在子组件留下<solt name="one"\></solt\>标签
  - 在父组件中的子组件标签中写内容，使用<template  slot="two"\>  内容</template\>书写
- 作用域插槽

# 混入（mixin)

## 1、什么是混入？

​		将组件的公共逻辑和配置提取出来，哪个组件需要的时候，直接将提取的这部分直接混入到组件内部即可，这样可以减少代码冗余度，也可以让后期维护起来更加容易。

## 2、Mixin和Vuex的区别？

​		上面一点说Mixin就是一个抽离公共部分的作用。在Vue中，Vuex状态管理似乎也是做的这一件事，它也是将组件之间可能共享的数据抽离出来。两者看似一样，实则还是有细微的区别，区别如下：

- Vuex公共状态管理，如果在一个组件中更改了Vuex中的某个数据，那么其它所有引用了Vuex中该数据的组件也会跟着变化。
- Mixin中的数据和方法都是独立的，组件之间使用后是互相不影响的。

## 3、mixin的优缺点?

特点：

1. 组件调用了混入的对象，故而混入的选项会合并到当前组件中去
2. 当混入的对象和组件含有同名选项时，以组件数据优先
3. 当多个组件引入混入方法时，其中一个组件里面改变了混入中的某个属性值或者方法内部的操作时，其他组件不会受影响

优点:

- 提高代码复用性
- 无需传递状态
- 维护方便，只需要修改一个地方即可

缺点:

- 命名冲突
- 滥用的话后期很难维护
- 不好追溯源，排查问题稍显麻烦
- 不能轻易的重复代码

# 父子通信

# vue-router的底层原理

# vue请求数据放在created好还是mounted里好？

建议放在created里

created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。

如果在mounted钩子函数中请求数据可能导致页面闪屏问题
其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了

# 请你说说vue中$nextTick用法及原理、

 **定义**

​		**官方理解**：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM

​		**个人理解**：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，即数据更新了，在dom渲染完成后调用该函数

**应用场景**

- 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中
- 在created()钩子函数执行的时候DOM 其实并未进行任何渲染

​		在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。