# 一、基础总结深入

## 1、数据类型

### 1.1、分类

- 基本（值）类型

1. String ：任意字符
2. Number：任意数字
3. boolean：true/false
4. undefined：undefined
5. null：null

- 对象（引用）类型

1. Object：任意对象
2. Function：一种特别的对象（可以执行）
3. Array：一种特别的对象（数值下标，内部数据是有序的）

### 1.2、判断

- typeof
  - 返回数据数据类型的字符串表达式
  - 可以判断undefined / 数值 / 字符串 / 布尔值
  - 不能判断：null与object object与array
- instanceof
  - 判断对象的具体类型
- ===
  - 可以判断：undefined，null

### 1.3、相关问题

- undefined与null的区别？
  - undefined代表定义未赋值
  - null定义并赋值了，只是值为null
- 什么时候给变量赋值为null呢？
  - 初始赋值，表明将要赋值为对象
  - 结束前，让对象成为垃圾对象（被垃圾回收器回收）
- 严格区别变量类型与数据类型？
  - 数据类型
    1. 基本类型
    2. 对象类型
  - 变量类型
    1. 基本类型：保存就是基本类型的数据
    2. 引用类型：保存的是地址值

## 2、数据、变量、内存

①、什么是数据？

- 存储在内存中代表特定信息的 ’东东‘，本质上0101...
- 数据的特点：可传递、可运算
- 一切皆数据
- 内存中所有操作的目标：数据
  - 算数运算
  - 逻辑运算
  - 赋值
  - 运行函数

②、什么是内存？

- 内存条通电后产生的可存储数据的空间（临时的）
- 内存产生和死亡：内存条（电路板）==》通电 ==》产生内存空间 ==》存储数据 ==》处理数据 ==》内存空间和数据都消失

③、什么是变量？

- 可变化的量，由变量名和变量值组成
- 每个变量对应的一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据
- 一块小内存的两个数据
  - 内部存储的数据
  - 地址值

- 内存分类
  - 栈：全局变量/局部变量
  - 堆：对象

④、内存，数据，变量三者之间的关系

- 内部用来存储数据的空间
- 变量是内存的标识

⑤、相关问题

- 关于赋值和内存的问题
  - 问题：var a = xxx，内存中到底保存的是什么？
    1. xxx是基本数据，保存的就是这个数据
    2. xxx是对象，保存的是对象的地址值
    3. xxx是一个变量，保存的就是xxx的内存内容（可能是基本数据，也可能是地址值）
  
- 关于引用变量赋值问题

  - n个引用变量指向同一个对象，通过一个变量修改对象内存数据，其他所有变量看到的是修改之后的数据

  - n个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，其他变量指向不变、

- 问题：在JS调用函数时传递变量参数时，是值传递还是引用传递
  - 理解1：都是值（基本/地址值）传递
  - 理解2：可能是值传递，也可能是引用地址值（地址值）
- 问题：JS引擎如何管理内存？
  - 内存生命周期
    1. 分配小内存空间，得到它的使用权
    2. 存储数据，可以反复进行操作
    3. 释放小内存空间
  - 释放内存
    1. 局部变量：函数执行完自动释放
    2. 对象：成为垃圾对象==》垃圾回收器回收

## 3、对象

①、什么是对象？

- 多个数据的封装体
- 用来保存多个数据的容器
- 一个对象代表现实中的一个事物

②、为什么要用对象？

- 统一管理多个数据

③、对象的组成？

- 属性：属性名（字符串）和属性值（任意）组成
- 方法：一种特别的数据（属性值是函数）

④、如何访问对象内部数据？

- .属性名：编码简单，有时不能用
- [’属性名字符串‘]：编码复杂，能通用

⑤、相关问题

- 问题：什么时候必须使用 ['属性名'] 的方式？

  1. 属性名包含特殊字符：- 空格
  2. 属性名不确定
  3. 案例

  ```
  1、属性名包含特殊字符
  var p = {}
  p.content-type = 'text/json'
  p['content-type'] = 'text/json'
  
  2、属性名不确定
  var proname = 'myAge'
  var value = 18
  p.proname = value //不可用
  p[proname] = value
  ```


## 4、函数

①、什么是函数？

- 具有特定功能的n条语句的封装体
- 只要函数时可以执行的，其它类型的数据不能执行
- 函数也是对象

②、为什么要用函数？

- 提高代码复用
- 便于阅读交流

③、如何定义函数？

- 函数声明
- 表达式
  - 实例：

```js
function fn1 () {	//函数声明
	console.log('fn1')
}

var fn2 = function() {	//表达式
	console.log('fn2')
}
```

④、如何调用（执行）函数

- test()：直接调用
- obj.test()：通过对象调用
- new test()：new调用
- test.call/apply(obj)：临时让test成为obj的方法进行调用

⑤、回调函数

- 什么函数才是回调函数？
  - 你定义的
  - 你没有调用
  - 但最终它执行了

- 常见的回调函数？

  - dom事件回调函数 ==> 发生事件的dom元素

  - 定时器回调函数 ==> window

  - ajax请求回调函数

  - 生命周期回调函数

⑥、IIFE

- 理解
  - 全程：Immediately-Invoked Function Expression
- 作用

  - 隐藏实现
- 不会污染外部（全局）命名空间
- 别称：立即执行函数

⑦、函数中的this

- this是什么？

  - 任何函数本质上都是通过某个对象来调用的

  - 所有函数内部都有一个变量this

  - 它的值是调用函数的当前对象

- 如何确定this的值？

  - test()：window

  - p.test()：p

  - new test()：新创建的对象

  - p.call(obj)：obj

# 二、函数高级

## 1、原型/原型链

### 1.1、原型

- 函数的prototype属性（图）
  - 每个函数都有一个prototype属性，它默认指向一个Object空对象（即称为：原型对象）
  - 原型对象中有一个属性constructor，它指向函数对象
- 给原型对象添加属性(一般都是方法)
  - 作用：函数的所有实例对象自动拥有原型中的属性(方法)


### 1.2、显式原型与隐式原型

- 每个函数function都有一个prototype，即显式原型（属性）
- 每个实例对象都有一个\__proto__，可称为隐式原型（属性）
- 对象的隐式原型的值为其对应构造函数的显式原型的值
- 内存结构（图）

![](截图\原型对象)


![image-20220609180939120](截图\原型链)

①、构造函数/原型/实例对象的关系（图解）

![image-20220609202541538](截图\关系图1)

②、构造函数/原型/实例对象的关系2（图解）

![image-20220609202829809](截图\关系图2)

③、原型继承

- 构造函数的实例对象自动拥有构造函数原型对象的属性（方法）
- 利用的就是原型链

④、原型的属性问题

- 读取对象属性值时：会自动到原型链中查找
- 设置对象的属性时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置值
- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上 

### 1.3、探索instanceof

①、instanceof是如何判断的？

- 表达式：A instanceof B
- 如果B函数的显式原型属性在A对象的原型链上，返回true，否则返回false

②、Function是通过new自己产生的实例

## 2、执行上下文与执行上下文栈

### 2.1、变量提升与函数提升

①、变量提升和函数提升

- 通过var定义（声明）的变量，在定义语句之前就可以访问到
- 值：undefined

②、函数声明提升

- 通过function声明的函数，在之前就可以直接调用
- 值：函数定义（对象）

③、问题：变量提升和函数提升如何产生？

- 案例

```
fn1()		//能调用	函数提升
fn2()		//不能调用	变量提升

function fn1() {
	console.log('fn1')
}
var fn2 = funciton() {
	console.log('fn2')
}
```

### 2.2、执行上下文

①、代码的分类（位置）

- 全局代码
- 函数（局部）代码

②、全局执行上下文

- 在执行全局代码前window确定为全局执行上下文
- 对全局数据进行预处理
  - var定义的全局变量==》undefined，添加为window属性
  - function声明的全局函数==》赋值（fun）,添加为window的方法
  - this==》赋值（window）
- 开始执行全局代码

③、函数执行上下文

- 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的存在于栈中）
- 对局部数据进行预处理
  - 形参变量==》赋值（实参）==》添加为执行上下文的属性
  - arguments==》赋值（实参列表），添加为执行上下文的属性
  - var定义的局部变量==》undefined，添加为执行上下文的属性
  - function声明的函数==》赋值（fun)，添加为执行上下文的方法
  - this==》赋值（调用函数的对象）、
- 开始执行函数体代码

### 2.3、执行上下文栈

①、理解

1. 在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文（window）确定后，将其添加到占中（压栈）
3. 在函数执行上下文创建后，将其添加到栈中（压栈）
4. 在当前函数执行完后，将栈顶的对象移除（出栈）
5. 当所有的代码执行完后，栈中只剩下window

### 2.4、面试题

测试题1

```js
function a(){}		
var a
console.log(typeof a)	//function

总结：先执行变量提升，再执行函数提升
```

测试二

```
if(!(b in window)) {
	var b = 1
}
console.log(b)		//undefined

总结：
```

测试三

```js
var c = 1
function c(c) {
	console.log(c)
	var c = 3
}
c(2)	//报错

总结：c = 1 已经赋值，不会存在提升
```

## 3、作用域与作用域链

### 3.1、作用域

①、理解：

- 就是一块“地盘”，一个代码所在的区域
- 它是静态的（相对于上下文对象），在编写代码时就确定了

②、分类

- 全局作用域
- 函数作用域
- 块作用域

③、作用

- 隔离变量，不同作用域下同名变量不会有冲突

### 3.2、作用域与执行上下文

①、区别1

- 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时
- 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
- 函数执行上下文是在调用函数时，函数体代码执行之前创建

②、区别2

- 作用域是静态的，只要函数定义好了就一直存在，且不会改变
- 执行上下文是动态的，调用函数时创建，函数调用结束就会自动释放

③、联系

- 执行上下文环境（对象）是从 属于所在的作用域
- 全局上下文环境==》全局作用域
- 函数上下文环境==》对应的函数使用域

### 3.3、作用域链

①、理解

- 多个上下级关系的作用域形成的链，它的方向是从下向上（从内到外）
- 查找变量时就是沿着作用域链来查找

②、查找一个变量的查找规则

- 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2
- 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入3
- 在执行2的相同操作，直到全局作用域，如果还找不到就抛出找不到的异常

### 3.4、面试题

题1

```
var x = 10
function fn() {
	console.log(x)
}
function show(f) {
	var x = 20
	f()
}
show(fn)
```

题2

```
var fn = function () {
	console.log(fn)
}
fn()
var obj = {
	fn2:function () {
		console.log(fn2)
	}
}
obj.fn2()
```

## 4、闭包

### 4.1、理解闭包

①、如何产生闭包？

- 当一个嵌套在内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包

②、闭包到底是什么？

- 使用chrome调试查看
- 理解一：闭包是嵌套的内部函数（绝大部分人）
- 理解二：包含被引用变量（函数）的对象（极少数人）
- 注意：闭包存在于嵌套的内部函数中
- 执行函数定义就会产生闭包（不用调用函数）

③、产生闭包的条件？

- 函数嵌套
- 内部函数引用了外部函数的数据（变量/函数）

### 4.2、常见的闭包

- 将函数作为另一个函数的返回值

```js
function fn1() {
	var a = 2
	function fn2() {
		a++
		console.log(a)
	}
	return fn2
}
var f = fn1()
f()		//3
f()		//4
```



- 将函数作为实参传递给另一个函数调用

```js
function showTime(msg,times) {
	setTimeout(function() {
		alert(msg)
	},times)
}
特点：因为内部函数引用了外部函数的msg所以产生了闭包
```

### 4.3、闭包的作用

①、使用函数内部的变量在函数执行完后，仍然存货在内存中（延长了局部变量的声明周期）

②、让函数外部可以操作（读写）到函数内部的数据（变量/）

③、问题：

- 函数执行完后，函数内部声明的局部变是否还存在？
  - 一般是不存在，存在于闭中的变量才可能存在
- 在函数外部能直接访问函数内部的局部变量吗？
  - 不能，但我们可以通过闭包让外部操作它

### 4.4、闭包的生命周期

1. 产生：在嵌套内部函数定义执行完时就产生了（不是在调用）
2. 死亡：在嵌套的内部函数成为垃圾对象时

### 4.5、闭包的应用：自定义JS模板

- 具有特定功能的js文件
-  将所有的数据和功能都封装在一个函数内部（私有的）
- 只向外暴露一个包含n个方法的对象或函数
- 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能

### 4.6、闭包的缺点及解决

①、缺点：

- 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
- 容易造成内存泄漏

②、解决：

- 能不用闭包就不用
- 及时释放

### 4.7、面试题

题一

```js
 var name = 'ls'
        var obj = {
            name: 'zs',
            getName: function() {
                return function() {
                    return this.name
                }
            }
        }
        console.log(obj.getName()());	//ls

理解：obj.getName()此时this是obj,返回的是一个函数通过（）执行,this就是window
```

题二

```js
 var name = 'ls'
        var obj = {
            name: 'zs',
            getName: function() {
            	var that = this
                return function() {
                    return that.name
                }
            }
        }
        console.log(obj.getName()());	//zs
理解：使用that保存了obj的this，同时使用了闭包
```

# 三、面向对象高级

## 1、对象的创建模式

### 1.1、Object构造函数模式

- 套路：先创建空Object对象，再动态添加属性/方法
- 使用场景：起始时不确定对象内部数据
- 问题：语句太多
- 实例：

```js
var p = new Object()
p.name = 'zs'
p.age = 18
p.setName = function(name) {
	this.name = name
}
```



### 1.2、对象字面量

- 套路：使用{}创建对象，同时指定属性/方法
- 使用场景：起始时对象内部数据是确定的
- 问题：如果创建多个对象，有重复代码
- 实例：

```
var p = {
	name: 'zs',
	age: 12,
	setName: function(name) {
		this.name = name
	}
}
```



### 1.3、工厂模式

- 套路：通过工厂函数动态创建对象并返回
- 使用场景：需要创建多个对象
- 问题：对象没有一个具体的类型
- 实例

```
function createPserson(name age) {
	var obj = {
		name: name,
		age: age,
		setName:function (name) {
			this.name = name
		}
	}
	return obj
}
```

### 1.4、自定义构造函数模式

- 套路：自定义构造函数，通过new创建对象
- 使用场景：需要创建多个类型确定的对象
- 问题：每个对象都有相同的数据，浪费内存

```js
function Person(name,age) {
	this.name = name
	this.age = age
	this.setName = function(name) {
		this.name = name
	}
}
```

### 1.5、构造函数 + 原型的组合模式

- 套路：自定义的构造函数，属性在函数中初始化，方法添加到原型上
- 使用场景：需要创建多个类型确定的对象

```js
function Person(name,age) {
	this.name = name
	this.age = age
}
Person.prototype.setName = function(name) {
	this.name = name
}
```

## 2、继承模式

### 2.1、原型链继承

- 套路
  1. 定义父类型构造函数
  2. 给父类型的原型添加方法
  3. 定义子类型的构造函数
  4. 创建父类型的对象赋值给子类型的原型
  5. 将子类型原型的构造属性设置为子类型
  6. 给子类型的原型添加方法
  7. 创建子类型的对象：可以调用父类型的方法

- 实例

```
//父类型
function fu() {
	this.fName = 'zs'
}
fn.prototype.showFName = function() {
	console.log(this.fName)
}
//子类型
function zi() {
	this.zName = 'ls'
}
zi.prototype = new fu()
//子类型的原型为父类型的一个实例对象
zi.prototype = new fu()
//让子类型的原型的constructor指向子类
zi.prototype.constructor = zi
zi.prototype.showZName = function() {
	console.log(this.zName)
}

```

- 图例：

![image-20220611094956463](截图\原型链继承)

- 关键
  - 子类型的原型为父类型的一个实例对象

### 2.2、借用构造函数继承（假的）

- 套路：
  1. 定义父类构造函数
  2. 定义子类构造函数
  3. 在子类型构造函数中调动父类型构造函数
- 实例：

```js
function Person(name,age) {
	this.name = name
	this.age = age
}

function Students(name,age,price) {
    Person.call(this,name,age)	//相当于：this.Person(name,age)
    this.price = price
}
```



- 关键
  - 在子类型构造函数中通用super()调用父类型构造函数

### 2.3、组合继承

原型链+借用构造函数的组合继承

- 利用原型链实现对父类型对象的方法继承
- 利用super()借用父类型构建函数初始化相同属性

```
function Person(name,age) {
	this.name = name
	this.age = age
}
Person.prototype.setName = function(name) {
    this.name = name
}
function Students(name,age,price) {
    Person.call(this,name,age)	//相当于：this.Person(name,age)
    this.price = price
}
Students.prototype = new Person()	//为了能看到父类型的方法
Students.prototype.constructor = Students	//修改constructor
Students.prototype.setPrice = function(price) {
    this.price = price
}
```

## 3、问题

### 3.1、new一个对象背后做了些什么？

1. 创建一个空对象
2. 给对象设置____proto____，值为构造函数对象的prototype属性值，this._______proto____= Fn.prototype
3. 执行构造函数体(给对象添加属性/方法)

# 四、线程机制和事件机制

## 1、进程与线程

### 1.1、进程（process）

- 程序的一次执行，它占有一片独有的内存空间
- 可以通过window任务管理器查看进程

### 1.2、线程（thread)

- 是进程中的一个独立执行单元
- 是程序执行的一个完整流程
- 是CPU的最小的调度单元

### 1.3、图解

![image-20220611155116211](截图\进程图解)

### 1.4、相关问题

- 应用程序必须运行在某个进程的某个线程上
- 一个进程中至少有一个运行的线程：主线程，进程启动后自动创建的
- 一个进程中可以同时运行多个线程，我们会说程序是多线程运行的
- 一个进程内的数据可以供其中的多个线程直接共享
- 多个线程之间的数据是不能直接共享的
- 线程池(thread pool)：保存多个线程对象的容器，实现线程对象的反复利用

### 1.5、相关问题

1、何为多进程与多线程？

- 多进程运行：一个应用程序可以同时启动多个实例运行
- 多线程：在一个进程中，同时有多个进程运行

2、比较单线程与多线程？

- 多线程
  - 优点：
    - 能有效提高CPU的利用率
  - 缺点：
    - 创建多线程开销
    - 线程间切换开销
    - 死锁与状态同步问题
- 单线程
  - 优点：顺序编程简单容易
  - 缺点：效率低

3、JS是单线程还是多线程？

- js是单线程运行的
- 但使用H5中的Web Workers可以多线程运行

4、浏览器运行是单线程还是多线程?

- 都是多线程运行的

## 2、浏览器内核

支撑浏览器运行的最核心的程序，不同的浏览器可能不一样

### 2.1、主流浏览器内核

### 2.2、内核由很多模块组成

- 主线程
  - js引擎模块：负责js程序的编程与运行
  - html，css文档解析模块：负责页面文本的解析
  - DOM/CSS模块：负责dom / css在内存中的相关处理
  - 布局和渲染模块：负责页面的布局和效果的绘制(内存中的对象)

- 分线程
  - 定时器模块：负责定时器的管理
  - DOM事件响应模块：负责事件的管理
  - 网略请求模块：负责ajax请求


## 3、定时器引发的思考

### 3.1、定时器真是定时执行的吗？

- 定时器并不能保证真正定时执行 
- 一般会延迟一丁点（可以接受），也有可能延迟很长时间（不能接受）

### 3.2、定时器回调函数是在哪个线程执行的？

- 在主线程执行的，js是单线程的

### 3.3、定时器是如何实现的？

- 事件循环模型

## 4、JS是单线程执行的

### 4.1、如何证明js执行是单线程的？

- setTimeout()的回调函数是在主线程执行的
- 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

### 4.2、为什么js要用单线程模式，而不用多线程模式？

- JavaScript的单线程，与它的用途有关
- 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM
- 这决定了它只能是单线程，否则会带来很复杂的同步问题

### 4.3、代码的分类：

- 初始化代码
- 回调函数

### 4.4、js引擎执行代码的基本流程

- 先执行初始化代码：包含一些特别的代码、
  - 设置定时器
  - 绑定监听
  - 发送ajax请求
- 后面在某个时刻才会执行回调函数

## 5、浏览器的事件循环(轮询)模型

### 5.1、所有代码分类

- 初始化执行代码(同步代码)：包含绑定dom事件监听，设置定时器，发送ajax请求的代码
- 回调执行代码(异步代码)：处理回调函数

### 5.2、js引擎执行代码的基本流程：

- 初始化代码==》回调函数

### 5.3、模型的2个重要组成部分

- 事件(定时器/DOM事件/Ajax)管理模型
- 回调函数

### 5.4、模型的运转流程

- 执行初始化代码，将事件回调函数交给对应模块管理
- 当事件发生时，管理模块会将回调函数及其数据添加到回调列队中
- 只有当初始化代码执行完后(可能要一定时间)，才会遍历读取回调队列中的回调函数执行

### 5.5、相关重要概念

- 执行栈：execution stack，所有代码都是在此空间中执行的
- 浏览器内核
  - browser core
  - js引擎模块(在主线程处理)
  - 其它模块(在主/分线程处理)
- callback queue
  - 任务队列：task queue
  - 消息队列：message queue
  - 事件队列：event queue
- 事件轮询：event loop，从任务队列中循环去除回调函数放入执行栈中处理(一个接一个)
- 事件驱动模型：event-driven interaction model
- 请求响应模型：request-response model

### 5.6、模型原理图

![image-20220612112100488](\截图\JS进阶\模型原理图)

## 6、H5 Web Workers(多线程)

### 6.1、介绍

- Web Workers 是HTML5提供的一个javascript多线程解决方案
- 我们可以将一些大量计算的代码交由Web Work运行而不冻结用户界面
- 但子线程完全受主线程控制，且不得操作DOM所以，这个新标砖并没有改变JavaScript单线程的本质

### 6.2、使用

- 创建在分线程执行的js文件

```
var onmessage = function(event) { //不能用函数声明
	console.log('onMessage()')
	 var upper = event.data.toUpperCase()	//通过event.data获取发送过来的数据
	 postMessage(upper)	//数据发送给主线程
}
```



- 在主线程中的js中发消息并设置回调函数

```js
//创建一个Worker对象并向它传递将在新线程中执行的脚本URL
var worker = new Worker("worker.js")
//接收worker传过来的数据函数
worker.onmessage = function(event) {
	console.log(event.data)
}
//想worker发送数据
worker.postMessage("hello world")
```

### 6.3、图解

![image-20220612130810507](截图\多线程图解)

### 6.4、不足

- 慢
- 不能跨域加载JS
- worker内代码不能访问DOM(更新UI)
- 不是每个浏览器都支持这个新特性

# 补充

## 1、分号问题

- js一条语句的后面可以不加分号
- 是否加分号是编码风格问题，没有应不应该，只有你自己喜不喜欢
- 在下面2种情况下不加分号会有问题
  1. 小括号开头的前一句语句
  2. 中括号开头的前一句语句
- 解决办法：在首行加分号

## 2、内存溢出与内存泄漏

①、内存溢出

- 一种程序运行出现的错误
- 当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误

②、内存泄漏

- 占用的内存没有及时释放
- 内部泄漏积累多了就容易导致内存溢出
- 常见的内存泄漏
  - 意外的全局变量
  - 没有及时清理的计时器或回调函数
  - 闭包

